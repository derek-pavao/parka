<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Parka</title>
    <link>http://dotdeeka.github.io/parka/</link>
    <description>Recent content on Parka</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 05 Apr 2016 15:56:40 -0400</lastBuildDate>
    <atom:link href="http://dotdeeka.github.io/parka/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Database Access</title>
      <link>http://dotdeeka.github.io/parka/database-access/</link>
      <pubDate>Tue, 05 Apr 2016 15:56:40 -0400</pubDate>
      
      <guid>http://dotdeeka.github.io/parka/database-access/</guid>
      <description>

&lt;h2 id=&#34;overview&#34;&gt;Overview&lt;/h2&gt;

&lt;p&gt;Parka uses a great lightweight ORM that mostly stays out of the developers way.
&lt;a href=&#34;http://vincit.github.io/objection.js/#relationexpression&#34;&gt;Objection.js&lt;/a&gt;. And Parka mostly stays out of the way
as well.&lt;/p&gt;

&lt;p&gt;The only thing required for a model from Parka is that you extend &lt;code&gt;ParkaModel&lt;/code&gt; and you decorate your model class
with &lt;code&gt;@TableName(&#39;name_of_the_table&#39;)&lt;/code&gt; Other than that, its just Objection.js&lt;/p&gt;

&lt;h2 id=&#34;example&#34;&gt;Example&lt;/h2&gt;

&lt;p&gt;The Todos model&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import {ParkaModel, TableName} from &#39;parka&#39;;

@TableName(&#39;Todo&#39;)
export let Todo extend ParkaModel {

  public title: string;
  public description: string;
  public done: number;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;validation&#34;&gt;Validation&lt;/h2&gt;

&lt;p&gt;Objection.js validates models by a &lt;a href=&#34;http://json-schema.org/&#34;&gt;JsonSchema&lt;/a&gt; definition defined as a static property on your model.
For example to define our Todo model and make title and description required, give title a maximum length, and give done a
default value of 0, it would look like the following;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import {ParkaModel, TableName} from &#39;parka&#39;;

@TableName(&#39;Todo&#39;)
export let Todo extend ParkaModel {

  public static jsonSchema = {
    type: &#39;object&#39;,
    required: [&#39;title&#39;, &#39;description&#39;],

    properties: {
      title: {
        type: &#39;string&#39;,
        maxLength: 50
      },
      description: {
        type: &#39;string&#39;
      },
      done: {
        type: &#39;integer&#39;,
        default: 0
      }
    }
  };

  public title: string;
  public description: string;
  public done: number;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the future it is possible that Parka will provide some syntactic sugar for defining these constraints, mostlikely with
decorator metadata. However, for now defining the static jsonSchema property is easy enough.&lt;/p&gt;

&lt;p&gt;For more information on &lt;a href=&#34;http://vincit.github.io/objection.js/#relationexpression&#34;&gt;Objection.js&lt;/a&gt; check out their website&lt;/p&gt;

&lt;div class=&#34;admonition note&#34;&gt;
&lt;p class=&#34;admonition-title&#34;&gt;Promises and Objection.js&amp;#39;s QueryBuilder&lt;/p&gt;
&lt;p&gt;Objection.js uses Promises/Thenables and Parka is designed to work well with them. Objection.js&amp;rsquo;s query methods all return an
instance of their QueryBuilder. If you return a QueryBuilder instance or a Promise/Thenable from any Parka Resource method, Parka
will wait till that call is resolved completely and then return the resolved value to the client.&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;example-w-promises&#34;&gt;Example w/ Promises&lt;/h2&gt;

&lt;p&gt;Our Todo model above inherits some methods from Objection.js, one of which is &lt;code&gt;query()&lt;/code&gt;. The query() method returns a promise
that resolves with a complete list of everything from the given models table, i.e. Todo.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import {Path, GET} from &#39;parka&#39;;
import {Todo} from &#39;../models/todo&#39;;


@Path(&#39;/todo&#39;)
export class TodoResource {

  @GET
  public getListOfTodos() {
    return Todo.query();
  }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets say you had two lists of models you wanted to return in the same request&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import {Path, GET} from &#39;parka&#39;;
import {Todo} from &#39;../models/todo&#39;;
import {AnotherModel} from &#39;../models/todo&#39;;
import * as Promise from &#39;bluebird&#39;;


@Path(&#39;/todo&#39;)
export class TodoResource {

  @GET
  @Path(&#39;/with-other-model&#39;)
  public getListOfTodosWithOtherModelList() {

    return Promise.all([
      Todo.query(),
      AnotherModel.query()
    ])
    .spread(function (todos, otherModels) {
      return {
        todos: todos,
        otherModels: otherModels
      };
    });
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the above examples, Parka will handle returning the resolved value to the client for you. For more info check out the section
of these docs about Resource Classes&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Resource Classes</title>
      <link>http://dotdeeka.github.io/parka/resource-classes/</link>
      <pubDate>Fri, 01 Apr 2016 19:37:59 -0400</pubDate>
      
      <guid>http://dotdeeka.github.io/parka/resource-classes/</guid>
      <description>

&lt;p&gt;As mentioned on the main page. In Parka, routes are defined as part of Resource classes. These
classes and their methods are decorated with the appropriate decorators in order to tell Parka what methods should
respond to which routes.&lt;/p&gt;

&lt;p&gt;In the following examples and in all examples on this docs site we will be using an API for the typical TodoMVC application.
Sorry, I couldn&amp;rsquo;t think of anything more exciting. Also, these examples will have some code from the ORM used in Parka,
&lt;a href=&#34;http://vincit.github.io/objection.js/&#34;&gt;Objection.js&lt;/a&gt;, we&amp;rsquo;ll talk in detail about the ORM in another section.&lt;/p&gt;

&lt;h2 id=&#34;basic-get-request&#34;&gt;Basic GET Request&lt;/h2&gt;

&lt;p&gt;Lets ignore the fact that we haven&amp;rsquo;t talked about database access yet. Just note that all the methods of the ORM
return Promsies, so every resource method will return to the client the value those Promises are resolve with.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import {Path, GET} from &#39;parka&#39;;
import {Todo} from &#39;../models/todo&#39;;


@Path(&#39;/todo&#39;)
export class TodoResource {

  @GET
  public getListOfTodos() {
    return Todo.query();
  }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the code above we have some slightly different code than the first example. The class stills has the
&lt;code&gt;@Path(&#39;/todo&#39;)&lt;/code&gt; decorator on it. but note, the &lt;code&gt;getListOfTodos()&lt;/code&gt; method does not have a &lt;code&gt;@Path()&lt;/code&gt;
decorator at all, only a &lt;code&gt;@GET&lt;/code&gt;. In this case the &lt;code&gt;getListOfTodos()&lt;/code&gt; method will be mapped to the route url
for this resource class. When a user makes a get request to &lt;code&gt;GET http://&amp;lt;my_url&amp;gt;/todo&lt;/code&gt; they will be returned a JSON array
of all the Todo objects in the database.&lt;/p&gt;

&lt;h2 id=&#34;path-parameters&#34;&gt;Path Parameters&lt;/h2&gt;

&lt;p&gt;Paths often contain parameters we need to parse, for example when getting just one Todo out of the database. Lets see
what that looks like.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import {Path, PathParam, GET} from &#39;parka&#39;;
import {Todo} from &#39;../models/todo&#39;;


@Path(&#39;/todo&#39;)
export class TodoResource {

  @GET
  @Path(&#39;/:id&#39;)
  public getTodo( @PathParam(&#39;id&#39;) id ) {
    return Todo.query()
               .findById(id);
  }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this code we see the &lt;code&gt;@Path(&#39;/:id&#39;)&lt;/code&gt;. The string passed to the Path decorator is a pass through directly to Express.
So any valid parameter value in Express is valid here. Then in our method signature we see our id parameter is decorated with
&lt;code&gt;@PathParam(&#39;id&#39;)&lt;/code&gt;. The string passed to the PathParam decorator should match the named route param passed the the &lt;code&gt;@Path()&lt;/code&gt;
decorator. NOTE: Currently all &lt;code&gt;@PathParam()&lt;/code&gt;&amp;rsquo;s are passed as strings&lt;/p&gt;

&lt;h2 id=&#34;query-parameters&#34;&gt;Query Parameters&lt;/h2&gt;

&lt;p&gt;Endpoints can some times have query parameters to define optional parameters that may be sent to the server. One example
of this is defining what order an array of results should be returned in. Lets build on our previous example of getting a list of
todos from the database.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import {Path, PathParam, GET, QueryParam} from &#39;parka&#39;;
import {Todo} from &#39;../models/todo&#39;;


@Path(&#39;/todo&#39;)
export class TodoResource {

  @GET
  public getListOfTodos( @QueryParam(&#39;sortOrder&#39;) sortOrder ) {
    sortOrder = sortOrder || &#39;asc&#39;;

    return Todo.query()
               .orderBy(&#39;id&#39;, sortOrder);
  }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This example is almost exactly the same as our previous example, but with the adition of parameter
to our route method, &lt;code&gt;sortOrder&lt;/code&gt;. &lt;code&gt;sortOrder&lt;/code&gt; is annotated with &lt;code&gt;@QueryParam(&#39;sortOrder&#39;)&lt;/code&gt; this will
map a query parameter in the URL named &lt;code&gt;sortOrder&lt;/code&gt; to this parameter of our method, also named &lt;code&gt;sortOrder&lt;/code&gt;.
For example: A user makes a request to &lt;code&gt;GET http://&amp;lt;my_url&amp;gt;/todo?sortOrder=desc&lt;/code&gt; a list of todos from the
database will be returned as before. Except, this time they will be in reverse order.&lt;/p&gt;

&lt;h2 id=&#34;request-body&#34;&gt;Request Body&lt;/h2&gt;

&lt;p&gt;POST requests (and others) often contain a body to the request. Reading that body, as an instance of one of your models,
is very easy with Parka. This is an example of creating a new Todo.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import {Path, PathParam, POST, QueryParam} from &#39;parka&#39;;
import {Todo} from &#39;../models/todo&#39;;


@Path(&#39;/todo&#39;)
export class TodoResource {

  @POST
  public createNewTodo(@RequestBody(Todo) todo) {

    return Todo.query()
               .insert(todo);
  }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;@RequestBody&lt;/code&gt; gets passed one parameter, the Constructor for the class you want to create. When parka parses the request
it will take the request body and create a new instance of the Constructor and pass it in as the todo parameter in this example.&lt;/p&gt;

&lt;p&gt;One main advantage of doing this is that Objection.js (the ORM being used under the hood) does validation on the models
every time an instance is created. If the request body is not a valid Todo model, Objection.js will throw a ValidationError error,
and execution of this request will be halted and the error will be returned to the client.&lt;/p&gt;

&lt;div class=&#34;admonition note&#34;&gt;
&lt;p class=&#34;admonition-title&#34;&gt;Validation Errors from Objection.js&lt;/p&gt;
&lt;p&gt;Currently when Objection.js raises a ValidationError the response returned to the client is NOT in JSON format. This is something
I plan to change in the near future. An overarching goal of Parka is to always return JSON to the client and never plain text.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Getting Started Creating the TodoMVC API</title>
      <link>http://dotdeeka.github.io/parka/getting-started/</link>
      <pubDate>Fri, 01 Apr 2016 18:02:20 -0400</pubDate>
      
      <guid>http://dotdeeka.github.io/parka/getting-started/</guid>
      <description>

&lt;h2 id=&#34;global-dependencies&#34;&gt;Global Dependencies&lt;/h2&gt;

&lt;p&gt;Parka has a few global dependencies&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ npm install -g parka typescript ts-node pm2 nodemon
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;a-typical-directory-structure&#34;&gt;A typical Directory Structure&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;├── src // This is the directory that holds all the source files for your application
│   ├── app-config.ts // The config class for your application
│   ├── app.ts // The main application class
│   ├── config.yml // The settings and configuration for your application, you could have more than one of these
│   ├── models // Data model classes
│   │   └── todo.ts
│   └── resources // Resources classes, these classes define your routes
│       └── todo-resource.ts
├── dist // If you run parka start with the --production flag, TypeScript file are transpiled here before the app is run
├── logs // when running app with parka start log files are written here
├── package.json
├── tsconfig.json
└── README.md

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;creating-the-todomvc-api&#34;&gt;Creating the TodoMVC api&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ mkdir todos

# cd to the todos directory

$ cd todos
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;initialize-a-package-json-file&#34;&gt;Initialize a package.json file&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm init

# follow the prompts and answer all the question
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;create-a-tsconfig-json&#34;&gt;Create a tsconfig.json&lt;/h2&gt;

&lt;p&gt;This file tells ts-node and the TypeScript compiler how to compile the typescript&lt;/p&gt;

&lt;p&gt;./tsconfig.json&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
  &amp;quot;compilerOptions&amp;quot;: {
    &amp;quot;module&amp;quot;: &amp;quot;commonjs&amp;quot;,
    &amp;quot;target&amp;quot;: &amp;quot;es6&amp;quot;,
    &amp;quot;noImplicitAny&amp;quot;: false,
    &amp;quot;lib&amp;quot;: [&amp;quot;es6&amp;quot;],
    &amp;quot;sourceMap&amp;quot;: true,
    &amp;quot;moduleResolution&amp;quot;: &amp;quot;node&amp;quot;,
    &amp;quot;emitDecoratorMetadata&amp;quot;: true,
    &amp;quot;experimentalDecorators&amp;quot;: true,
    &amp;quot;rootDir&amp;quot;: &amp;quot;src&amp;quot;,
    &amp;quot;outDir&amp;quot;: &amp;quot;dist&amp;quot;
  },
  &amp;quot;compileOnSave&amp;quot;: false
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;parka-has-a-few-peer-dependencies-that-need-to-be-installed&#34;&gt;Parka has a few peer dependencies that need to be installed&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ npm install --save objection@next knex
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;installing-parka-locally&#34;&gt;Installing Parka locally&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ npm install parka --save
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;app-files&#34;&gt;App Files&lt;/h1&gt;

&lt;p&gt;Now that we&amp;rsquo;re set up we can get started on the application it self. Every Parka app
requires a main application class, a configuration class and a config.yml file. When
a Parka app boots up, the configuration yaml file is deserialized into an instance of
your configuration class, this is a great place to put environment specific parameters,
database connection parameters and such.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll put all of our source files in a directory &lt;code&gt;./src&lt;/code&gt;, we could call this anything really.
Parka makes no assumptions about your directory structure.&lt;/p&gt;

&lt;h2 id=&#34;creating-a-configuration-class&#34;&gt;Creating a configuration class&lt;/h2&gt;

&lt;p&gt;Our configuration class here is going to be extremely simple. Its going to be empty.
However we&amp;rsquo;re going to extend ParkaConfig which will handle configuration for things like
database connections.&lt;/p&gt;

&lt;p&gt;./src/app-config.ts&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import {ParkaConfig} from &#39;parka&#39;;

export class AppConfig extends ParkaConfig {

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;config-yml&#34;&gt;config.yml&lt;/h2&gt;

&lt;p&gt;When you start your app you will give it a configuration yaml file to use. You would probably have a few of these for different environments. But here we&amp;rsquo;re just going to have one
with some simple database connection parameters defined in it.&lt;/p&gt;

&lt;p&gt;./src/config.yml&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;appName: TodoMVC-API
env: dev
includeStackTraceInResponse: true
host: 127.0.0.1
port: 3000
db:
  client: sqlite3
  connection:
    filename: ./db.sqlite
  useNullAsDefault: true
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;install-sqlite3&#34;&gt;Install sqlite3&lt;/h2&gt;

&lt;p&gt;You will mostlikely need to install sqlite3 on your system using a package manager, and the npm module for it&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# This command is for OSX users using homebrew, For other package managers apt, yum, NuGet you will have to google it
$ brew install sqlite3

$ npm install sqlite3 --save

# create the database file, this also logs you in
$ sqlite3 db.sqlite
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Execute the following create table statement to create our Todo table&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE TABLE Todo (
  id INTEGER PRIMARY KEY,
  title varchar(255) NOT NULL,
  description TEXT NOT NULL,
  done INTEGER
);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ .exit
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;creating-an-application-class&#34;&gt;Creating an application class&lt;/h2&gt;

&lt;p&gt;Our application class is the main entry point into our application. It is where we will register all our Resource Classes with Parka. Registering these
classes will take place in the &lt;code&gt;onBeforeApplicationStart()&lt;/code&gt; lifecycle callback&lt;/p&gt;

&lt;p&gt;./src/app.ts&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import {ParkaApp} from &#39;parka&#39;;
import {AppConfig} from &#39;./app-config&#39;;
import {TodoResource} from &#39;./resources/todo-resource&#39;;

class App extends ParkaApp&amp;lt;AppConfig&amp;gt; {

  public onBeforeApplicationStart() {

    this.registerResource(TodoResource);
  }
}

// Instatiate and export a new instance of your application
export let app = new App(AppConfig);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;creating-a-model-to-represent-our-todo&#34;&gt;Creating a Model to represent our Todo&lt;/h2&gt;

&lt;p&gt;./src/models/todo.ts&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;import {ParkaModel, TableName} from &#39;parka&#39;;

@TableName(&#39;Todo&#39;)
export let Todo extends ParkaModel {

  public static jsonSchema = {
    type: &#39;object&#39;,
    required: [&#39;title&#39;, &#39;description&#39;],

    properties: {
      title: {
        type: &#39;string&#39;,
        maxLength: 50
      },
      description: {
        type: &#39;string&#39;
      },
      done: {
        type: &#39;integer&#39;,
        default: 0
      }
    }
  };

  public title: string;
  public description: string;
  public done: number;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This model is using Objection.js, you can read more about it in the DatabaseAccess section of these docs.&lt;/p&gt;

&lt;h2 id=&#34;routes-and-resource-classes&#34;&gt;Routes and Resource classes&lt;/h2&gt;

&lt;p&gt;We are going to create a resource class that will define routes to do simple CRUD on a Todo. More info
on defining Resource Classes can be found in the Resource Classes section of these docs&lt;/p&gt;

&lt;p&gt;./src/resources/todo-resource.ts&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import {
    Path,
    GET,
    POST,
    PUT,
    RequestBody,
    PathParam
} from &#39;parka&#39;;

import {Todo} from &#39;../models/todo&#39;;


@Path(&#39;/todo&#39;)
export class TodoResource {

    @GET
    public getListOfTodos() {

        return Todo.query();
    }

    @GET
    @Path(&#39;/:id&#39;)
    public getTodoById(@PathParam(&#39;id&#39;) id: string) {

        return Todo.query()
            .findById(id);
    }

    @POST
    public createNewTodo(@RequestBody(Todo) todo: Todo) {

        return Todo.query()
            .insert(todo);
    }

    @PUT
    @Path(&#39;/:id&#39;)
    public updateTodo(@PathParam(&#39;id&#39;) id: string,
                      @RequestBody(Todo) todo: Todo): any {

        if (todo.id !== Number(id)) {

            return Promise.reject({statusCode: 419, message: &#39;Conflict there was a id mismatch&#39;});
        } else {
            return Todo.query()
                .updateAndFetchById(id, todo);
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;run-the-app&#34;&gt;Run the app&lt;/h2&gt;

&lt;p&gt;Lets run the app in dev mode where it will watch for changes and reload the app when they occur. From the root
directory of the project run&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ parka watch src/app.ts src/config.yml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Your app should be running on &lt;a href=&#34;http://localhost:3000&#34;&gt;http://localhost:3000&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Parka</title>
      <link>http://dotdeeka.github.io/parka/</link>
      <pubDate>Tue, 08 Mar 2016 21:07:13 +0100</pubDate>
      
      <guid>http://dotdeeka.github.io/parka/</guid>
      <description>

&lt;div class=&#34;admonition note&#34;&gt;
&lt;p class=&#34;admonition-title&#34;&gt;Not Production Ready&lt;/p&gt;
&lt;p&gt;Parka is still in a pre-alpha type state, and is not feature complete let alone stable and ready for the prime time&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;what-is-parka&#34;&gt;What is Parka?&lt;/h2&gt;

&lt;p&gt;Parka is a server side framework that allows you to write simple REST services in TypeScript. It allows you to take advantage
of TypeScript decorators to do things like define routes in a simple and declaritive way. Parka takes its inspiration from
mainly two frameworks, &lt;a href=&#34;http://www.dropwizard.io/&#34;&gt;Dropwizard&lt;/a&gt; (a JAX-RS framework for Java) and &lt;a href=&#34;http://redstonedart.org/&#34;&gt;Redstone&lt;/a&gt;
a micro framework for the Dart programming language.&lt;/p&gt;

&lt;p&gt;Like Dropwizard I&amp;rsquo;m not sure if Parka is really a framework or a library. Its really just a thin layer that sits ontop of
Express.js and runs as a NodeJS application. It is simple, but what you end up with is a very clean and declaritive
way to write a REST API with Object Oriented style code.&lt;/p&gt;

&lt;h2 id=&#34;why-parka&#34;&gt;Why Parka?&lt;/h2&gt;

&lt;p&gt;A while back I had been playing around with the Dart language and saw the Redstone.dart framework. I liked both Dart and the
Redstone framework. However, the fact that I was a novice in Dart meant it took me a while to get anything done, so I ended
up going back to writing my side projects in NodeJS. Fast forward a few years and TypeScript is all the rage right now with
the guys on the Angular team at Google getting behind it and all. TypeScript has support for Decorators (which are similar
enough to Annotations that are present in languages like Java or Dart. The differences between these two I will save for another
time). Decorators would allow a framework like Redstone or Dropwizard to be writtin in TypeScript. And given TypeScript&amp;rsquo;s
great interop with the existing JavaScript ecosystem it makes a lot of sense.&lt;/p&gt;

&lt;h2 id=&#34;a-routing-example&#34;&gt;A Routing Example&lt;/h2&gt;

&lt;h3 id=&#34;defining-a-resource-class&#34;&gt;Defining a Resource Class&lt;/h3&gt;

&lt;p&gt;In Parka, routes are defined as part of Resource classes. These classes and their methods are decorated with the appropriate
decorators in order to tell Parka what methods should respond to which routes.&lt;/p&gt;

&lt;p&gt;In the following examples and in all examples on this docs site we will be using an API for the typical TodoMVC application.
Sorry, I couldn&amp;rsquo;t think of anything more exciting. Also, these examples will have some code from the ORM used in Parka,
&lt;a href=&#34;http://vincit.github.io/objection.js/&#34;&gt;Objection.js&lt;/a&gt;, we&amp;rsquo;ll get back to the ORM later.&lt;/p&gt;

&lt;h3 id=&#34;lets-start-with-a-resource-method-that-will-just-return-us-some-static-json-so-we-can-be-sure-it-is-working&#34;&gt;Lets start with a resource method that will just return us some static json so we can be sure it is working&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import {Path, GET} from &#39;parka&#39;;

@Path(&#39;/todo&#39;)
export class TodoResource {

  @GET
  @Path(&#39;/status&#39;)
  public returnStatus() {

    return {
      status: &#39;OK&#39;
    }
  }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets go over what this Resource Class does (when we register it with the Parka application, not shown here).
First we have two &lt;code&gt;@Path()&lt;/code&gt; decorators, one on the class it self, and one on the &lt;code&gt;returnStatus()&lt;/code&gt; method.
The &lt;code&gt;@Path()&lt;/code&gt; decorator on the class defines the root path for the entire resource class. And the &lt;code&gt;@Path()&lt;/code&gt;
decorator on the &lt;code&gt;returnStatus()&lt;/code&gt; method is added to that root path to form the route that gets registered. In addition
to the &lt;code&gt;@Path()&lt;/code&gt; decorators the &lt;code&gt;returnStatus()&lt;/code&gt; method has a &lt;code&gt;@GET&lt;/code&gt; decorator on it. This decorator signifies
which HTTP verb this method will respond to.&lt;/p&gt;

&lt;p&gt;For example. When this code above is registered with Parka a route for &lt;code&gt;GET http://&amp;lt;my_url&amp;gt;/todo/status&lt;/code&gt; will be registered
and when a user makes a GET request to that url they will get the &lt;code&gt;{ &amp;quot;status&amp;quot;: &amp;quot;OK&amp;quot; }&lt;/code&gt; JSON back as a response&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;admonition note&#34;&gt;
&lt;p class=&#34;admonition-title&#34;&gt;A Note on Promises / Thenables&lt;/p&gt;
&lt;p&gt;Parka has support for Promises and Thenables. If any Resource method returns a Promise or a Thenable, Parka will wait
till that promise is resolved and then return to the client whatever data the Promise was resolve with. Support for Promises
comes from the great &lt;a href=&#34;http://bluebirdjs.com/&#34;&gt;Bluebird&lt;/a&gt; library.&lt;/p&gt;
&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>